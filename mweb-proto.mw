# MWEB(prototype)

The previous work gives an overview of _Literate Programming_, but lacks of
another critical part for a complete literate programming system.  We will
fill this blank in this section to build a complete system, and introduce
_MWEB_'s innovation to _Literate Programming_.

Having a knowledge of how _MWEB_ deal with _.mw_ files at first might help
understanding following contents.  _MWEB(prototype)_ is designed to consist of
three phases of processing: first, preprocessing, synonymous to _C_'s; second,
declarative part's parsing; third, imperative part's executing.

Preprocessing, as you have met in _C_'s preprocessor, do a similar job,
in _MWEB(prototype)_, I only add one instruction in this phase,
```
	{at}i file [file1] [file2] ...
```
to include file, as same as _C_'s _#include_.  This instruction must be put at first of
a line, all preprocessing instruction should be in this way.  It can be used
anywhere, to include anything textual, but if you want to include a binary file,
I wont prevent you.

The following two phases are a little confussing, let me explain why I take
such an approach.  You might have heard of imperative or declarative
programming, I use these two words in the same means.  The _stage 0_ and _stage 1_
only deal with declarative statements, all works they do is parsing _.mw_ file's
description of code chunks, and do booting next stage by code hardcoded
into their source code.  I let the imperative hardcoded code exposed to users
of _MWEB(prototype)_, and do not give any wrapper on them, users must use
_MIT-Scheme_ to write this part of code.  The reason for this approach is that
although declarative code is expressive, using it to replace all actions
that _MWEB_ might take will require a lot of energy in definition of grammar,
and impose stress on users(they should follow me if I made any change on specification),
it's not ideal for both develpment and using of a prototype.  So I keep a few
declarative statements to express the spirit of _MWEB_, and put the remaining
miscellaneous on the imperative part.

The declarative part's grammar is similar to _stage 0_ and _stage 1_ but with
some extensions, which will be introduced later.  The imperative parts are expressed as:
```
	{at}e{at}[ code chunk name {at}]
```
A directive of this type will load and execute the corresponding _MIT Scheme_ code.

The whole program is divided to five parts.
@[mweb prototype@]
@{dependencies@}
@{macros@}
@{procedures@}
@{constants@}
@{variables@}
@

## I/O

We should redesign I/O procedures, because _MWEB(prototype)_ is supposed to be used
in a lot of situations despite it's a prototype.

We used to read in whole contents of a file as a string, but in order to do preprocessing,
a new input procedure is used.
@[procedures@]
(define (file->lines file)
  (let ((number 0))
    (map (lambda (l) (set! number (+ number 1)) (list l number file))
         @{lines read from _file_@})))
@

Every line is labeled with line number and file name.
@[procedures@]
(define (line-content line) (car line))
(define (line-number line) (cadr line))
(define (line-file line) (caddr line))
@

@[lines read from _file_@]
(call-with-input-file file
  (lambda (port)
    @{lines read from _port_@}))
@

@[lines read from _port_@]
(letrec
  ((get-lines (lambda ()
	        (let ((line (read-line port)))
	          (if (eof-object? line)
		      '()
		      (cons line (get-lines)))))))
  (get-lines))
@

Output consists of two parts.

@[dependencies@]
(load-option 'format)
@

## Parse

Like _stage 1_, we use _MIT scheme_'s parsing library.
@[dependencies@]
(load-option '*parser)
@

But unlike _stage 1_, _MWEB(prototype)_ parse file line by line for a better user experience.
@[procedures@]
(define (line->buffer line)
  (string->parser-buffer (line-content line)))
@

Some general matcher and parser macros are defined here.

@[constants@]
(define char-set:non-whitespace (char-set-invert char-set:whitespace))
(define char-set:all (char-set-union char-set:non-whitespace char-set:whitespace))
@

@[macros@]
(define-*matcher-macro space '(char-set char-set:whitespace))
(define-*matcher-macro spaces '(+ space))
(define-*parser-macro skip-spaces '(noise (alt (seq) (spaces))))
@

## Preprocess

We have only one preprocessing by now, including.

First, define its grammar.

File names can contain any character other than _"_.
@[constants@]
(define char-set:normal-file-name (char-set-difference char-set:non-whitespace (char-set #\")))
@

There are three basic elements:
@[macros@]
(define-*matcher-macro include-directive '(seq #\@ #\i))
(define-*matcher-macro file-name '(+ (char-set char-set:normal-file-name)))
(define-*matcher-macro file-name-quoted '(+ (not-char #\")))
@
The include directive accepts file names containing blanks, but you should quote them.

We parse an include directive to get a list of file names to include.
@[macros@]
(define-*parser-macro parse-include-directive
  '(seq (noise include-directive)
        (encapsulate vector->list @{parsing file names@})))
@

The directive can accept zero file names.
@[parsing file names@]
(* (seq (noise spaces)
	(alt (match file-name)
	     (seq (noise #\") (match file-name-quoted) (noise #\")))))
@

@[procedures@]
(define (preprocess lines)
  (let ((matcher (*matcher include-directive))
        (parser (*parser parse-include-directive)))
    (fold-right append '()
      (map @{parse and execute directives@} lines))))
@

@[parse and execute directives@]
(lambda (l)
  (let* ((buffer (line->buffer l))
         (result (parser buffer)))
    (if result
        (fold-right append '()
	  (map file->lines (vector-ref result 0)))
	(list l))))
@

## Declarative

What we have built in _stage 1_ is which I call Classic Literate Programming.
From now on, we are going to attach types to code chunks, not only names.
And this is the main innovation of MWEB.

Besides this, I also add cross-referencing to _MWEB(prototype)_.

We have to introduce new grammar for type declaration.
```
	{at}[ code chunk name {at}: type {at}]
	contents
	{at}d identifier1 identifier2 ...
	{at}r identifier1 identifier2 ...
	{at}
```

{at}d means _define_, {at}r means _reference_.  All three ways can be used to
end a code chunk, but {at} can not be used before {at}d or {at}r.  The order of
{at}d and {at}r doesn't matter.

Code chunk name and type name are same.
@[constants@]
(define char-set:name (char-set-invert (char-set #\@)))
@

@[macros@]
(define-*matcher-macro code-chunk-name
  '(seq (char-set char-set:non-whitespace)
        (? (seq (* (char-set char-set:name))
	        (char-set char-set:non-whitespace)))))
(define-*matcher-macro code-chunk-name-start-directive '(seq #\@ #\[))
(define-*matcher-macro code-chunk-name-end-directive '(seq #\@ #\]))
(define-*matcher-macro code-chunk-name-type-seperate-directive '(seq #\@ #\:))
@

Identifier names are like file names in preprocessing, but without quoted form.
@[constants@]
(define char-set:identifier-name char-set:non-whitespace)
@

@[macros@]
(define-*matcher-macro identifier-name '(+ (char-set char-set:identifier-name)))
(define-*matcher-macro define-directive '(seq #\@ #\d))
(define-*matcher-macro reference-directive '(seq #\@ #\r))
@

Having introduced new grammar, let's look at content to be parsed in a whole.
A complete _MWEB_ source file contains, as we have seen in _stage 1_, explanatory text
and code chunks.  The difference is, we use a line by line parsing strategy now,
so we can extract useful imformation in a more narrow range.

Any line not containing {at} at head can be accept as explanatory text.
@[macros@]
(define-*parser-macro parse-essay-line
  '(encapsulate (lambda (v) (cons 'essay-line (vector->list v)))
    (match (alt (seq (not-char #\@) (* (char-set char-set:all)))
                (end-of-input)))))
@

@[macros@]
(define-*parser-macro parse-code-chunk-start-line
  '(encapsulate (lambda (v) (cons 'start-line (vector->list v)))
    (seq (noise code-chunk-name-start-directive)
	 skip-spaces
	 (match code-chunk-name)
	 skip-spaces
	 (? @{parsing type name@})
	 (noise code-chunk-name-end-directive))))
@

@[parsing type name@]
(seq (noise code-chunk-name-type-seperate-directive)
     skip-spaces
     (match code-chunk-name)
     skip-spaces)
@

@[macros@]
(define-*parser-macro parse-code-chunk-content-line
  '(encapsulate (lambda (v) (cons 'content-line (vector->list v)))
    (match (alt (seq (not-char #\@) (* (char-set char-set:all)))
	        (seq #\@ (char-set char-set:not-end) (* (char-set char-set:all)))
		(end-of-input)))))
@

@[constants@]
(define char-set:not-end (char-set-difference char-set:non-whitespace (char-set #\d #\r)))
@

@[macros@]
(define-*parser-macro parse-code-chunk-end-line
  '(encapsulate (lambda (v) (cons 'end-line (vector->list v)))
    (alt @{parsing definition line@}
         @{parsing reference line@}
	 @{parsing end line@})))
@

@[parsing definition line@]
(encapsulate (lambda (v) (cons 'definitions (vector->list v)))
  (seq (noise define-directive)
       (* (seq (noise spaces) (match identifier-name)))))
@

@[parsing reference line@]
(encapsulate (lambda (v) (cons 'references (vector->list v)))
  (seq (noise reference-directive)
       (* (seq (noise spaces) (match identifier-name)))))
@

@[parsing end line@]
(encapsulate (lambda (v) '(end))
  (seq (noise #\@) skip-spaces (match (end-of-input))))
@

@[procedures@]
(define (parse-lines lines)
  (letrec ((context 'essay)
           (parse-line @{parse a line according to context@}))
    (map @{attach parsed information@} lines)))
@

@[attach parsed information@]
(lambda (l) (cons (parse-line l) l))
@

@[procedures@]
(define (parsed-line-info pl) (car pl))
(define (parsed-line-origin pl) (cdr pl))
(define (info-type info) (car info))
(define (info-value info) (cdr info))
(define (parsed-line-type pl) (info-type (parsed-line-info pl)))

(define (is-essay-line? pl) (eq? (parsed-line-type pl) 'essay-line))
@


@[parse a line according to context@]
(lambda (l)
  (let ((buffer (line->buffer l)))
    (case context
      ((essay) @{parse buffer in essay context@})
      ((code-start) @{parse buffer in code-start context@})
      ((code-content) @{parse buffer in code-content context@})
      ((code-end) @{parse buffer in code-end context@})
      (else (error "Some Error")))))
@

@[parse buffer in essay context@]
(let* ((parser (*parser parse-essay-line))
       (result (parser buffer)))
  (if result
      (vector-ref result 0)
      (begin
        (set! context 'code-start)
	(parse-line l))))
@

@[parse buffer in code-start context@]
(let* ((parser (*parser parse-code-chunk-start-line))
       (result (parser buffer)))
  (if result
      (begin
	(set! context 'code-content)
        (vector-ref result 0))
      (error "Some Error")))
@

@[parse buffer in code-content context@]
(let* ((parser (*parser parse-code-chunk-content-line))
       (result (parser buffer)))
  (if result
      (vector-ref result 0)
      (begin
        (set! context 'code-end)
	(parse-line l))))
@

@[parse buffer in code-end context@]
(let* ((parser (*parser parse-code-chunk-end-line))
       (result (parser buffer)))
  (if result
      (vector-ref result 0)
      (begin
        (set! context 'essay)
	(parse-line l))))
@

@[procedures@]
(define (gather parsed-lines)
  (let ((head-attached
          (reverse (map reverse
		        (fold @{add new line to gathered@} '((((essay-line start)))) parsed-lines)))))
    (cons (cdr (car head-attached)) (cdr head-attached))))
@

@[add new line to gathered@]
(lambda (parsed-line gathered)
  (let ((p1 (is-essay-line? parsed-line))
        (p2 (is-essay-line? (caar gathered))))
    (if (or (and p1 p2) (and (not p1) (not p2)))
        (cons (cons parsed-line (car gathered)) (cdr gathered))
        (cons (list parsed-line) gathered))))
@

