# Classic Literate Programming

The stage1's model supports the programming paradigm which I call
**Classic Literate Programming**.  In **Classic Literate Programming**,

@[mweb@]
@{grammar@}
@{tangle@}
@{weave@}
@{I/O@}
@

## I/O

@[I/O@]
(define file-max-size (expt 2 20))
(define (get-contents file)
  (call-with-input-file file
    (lambda (port)
      (read-string file-max-size port))))
(define (put-contents file contents)
  (call-with-output-file file
    (lambda (port)
      (write-string contents port))))
@

## Grammar

@[mweb@]
(define (tangle file node)
  ; tangle-node is just another form of tangle, use parsed file
  ; rather than file as argument
  (tangle-node (extract-code-chunks
		(parse-contents
		 (get-contents file)))
	       node))
@

MIT-scheme contains a useful library to do parsing.
@[mweb@]
(load-option '*parser)
@

As you might guess, the code chunks used in this stage also follow the new
syntax defined by this stage, but add something new inside code chunks.
Let's define the elements of MWEB stage1 one by one.

TEXT: the comments is of this type, since we do not have any
control sequence now, for convenience, we simply define it as this.
@[mweb@]
(define-*matcher-macro text
  `(+ (not-char #\@)))
@

NAME: the name of code chunks is of this type.
@[mweb@]
(define char-set:non-whitespace (char-set-invert char-set:whitespace))
(define-*matcher-macro name
  `(seq (char-set char-set:non-whitespace)
	(? (seq (* (not-char #\@))
		(char-set char-set:non-whitespace)))))

(define-*matcher-macro spaces
  `(* #\space))
@

CODE: the contents of a code chunk.
@[mweb@]
(define-*matcher-macro code
  `(* (alt (not-char #\@)
	   (seq #\@ (not-char #\newline)))))
@

Then build the parse processes, we do not use explaining text now, just ignore them.
@[mweb@]
(define-*parser-macro mweb-stage-1
  `(* (seq (? explain-text)
	   (encapsulate vector->list code-chunk))))

(define-*parser-macro explain-text
  `(noise text))
@

@[mweb@]
(define-*parser-macro code-chunk
  `(seq code-chunk-title (noise "\n")
	code-chunk-content
	code-chunk-end))

(define-*parser-macro code-chunk-title
  `(seq (noise "@[")
	(noise spaces)
	(match name)
	(noise spaces)
	(noise "@]")))

(define-*parser-macro code-chunk-content
  `(match code))

(define-*parser-macro code-chunk-end
  `(noise "@\n"))
@

@[mweb@]
(define (parse-contents contents)
  (let ((parser (*parser mweb-stage-1)))
    (vector->list (parser (string->parser-buffer contents)))))
@

@[mweb@]
(define (extract-code-chunks parsed-contents)
  (let ((hash-table (make-string-hash-table)))
    (for-each (lambda (chunk)
		(let* ((title (car chunk))
		       (contents (cadr chunk))
		       (contents-extracted
			(hash-table-ref hash-table title (lambda () ""))))
		  (hash-table-set! hash-table title
				  (string-append contents-extracted contents))))
	      parsed-contents)
    hash-table))
@

@[mweb@]
(define-*matcher-macro normal-code
  `(+ (alt (not-char #\@)
	   (seq #\@ (not-char #\{)))))

(define-*parser-macro node-contents
  `(* (alt (match normal-code)
	   (map (lambda (node) (tangle-node nodes node)) reference))))

(define-*parser-macro reference
  `(seq (noise (seq #\@ #\{ spaces))
	(match name)
	(noise (seq spaces #\@ #\}))))

(define (tangle-node nodes node)
  (let ((node-contents (hash-table-ref nodes node (lambda () "")))
	(parser (*parser node-contents)))
    (fold-right string-append "" (vector->list (parser (string->parser-buffer node-contents))))))
@

